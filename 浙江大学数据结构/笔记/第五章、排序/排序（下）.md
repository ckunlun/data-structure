# 排序（下）

[toc]

## 快速排序

在正确书写快速排序的情况下，大多数情况下快速排序算法表现好。

算法概述：

分而治之

![31 57 26  013 2631 4357 3758192)  أه  0 13 26 31 43 57 65 75 8192 ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001.png)

从一堆整数中，任选一个数做主元，将其作为枢纽把原来的集合分成两大块，然后分别递归的去处理左边和右边，然后将三块的结果放进一个数组里，就完成了快速排序。

* 细节

如何选择主元？

​	快速排序算法最好的情况是每次选择的主元都在数组中间。

如何根据主元分子集？

什么是快速排序算法的最好情况？

​	每次正好中分，T(N) =O(NlogN)

![image-20201006222348079](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006222348079.png)



* 选主元

1. 令pivot = A[0] ?

![ ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001-1601994379174.png)

T ( N ) = O( N ) + T ( N – 1 )

= O( N ) + O ( N – 1 ) + T( N – 2 )

= O( N ) + O ( N – 1 ) + …+ O( 1 )

= O( N^2^ )

对于排序算法而言，复杂度不够好。

2. 随机取pivot？rand()函数不便宜啊！

3.  取头、中、尾的中位数

    例如8、12、3的中位数就是8

   测试一下pivot不同的取法对运行速度有多大影响？

```c
ElementType Median3(ElementType A[], int Left, int Right)//选取主元
{
    int Center = (Left + Right) / 2;
    if (A[Left] > A[Center])
        Swap(&A[Left], &A[Center]);
    if (A[Left] > A[Right])
        Swap(&A[Left], A[Right]);
    if (A[Center] > A[Right])
        Swap(&A[Center], &A[Right]);
    // A[Left] <= A[Center] <= A[Right]
    Swap(&A[Center], &A[Right - 1]); //将pivot藏到右边
    // 只需要考虑A[Left + 1]...A[Right - 2]
    return A[Right - 1]; //返回pivot
}
```

* 子集划分

步骤：

1. 数组为选择主元后返回的数组，已经隐藏部分元素。其中6为主元。接下来寻找主元的正确位置，先定义两个指针i和j，分别指向数组的第一个元素和除主元外的倒数第一个元素。

![8  4  9  0  3  5  2  7  6 ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001-1601995107965.png)

先比较i所指的元素和主元谁大谁小，如过i所指元素大于主元，则发出红色警告，因为我们要求左边元素要小于等于主元，右边元素大于主元。

然后再看j指向的元素和主元的大小，如过j指向的元素大于主元，则表示符合要求，j--。继续判断下一个元素和主元的大小

![image-20201006224121256](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006224121256.png)

若不对则标记，当两边发现都有不对的元素的时候，将两边的元素进行交换。然后继续开始下一轮的比较。

![image-20201006224151338](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006224151338.png)

以此类推，重复执行上述操作，直到`i - j < 0`；

![image-20201006224407831](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006224407831.png)

此时i所处位置即为主元位置，此时交换主元和i所指元素

![image-20201006224434302](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006224434302.png)

快速排序快的缘由是每一次选定主元以后，主元在子集划分完以后就一次性的放到正确位置上，以后再也不会移动；不像插入排序，每一次做了元素交换以后，这个元素所在位置是临时的，当下一个数据插入的时候，其他元素有可能都需要改变。

* 如果有元素正好等于pivot怎么办？
  * 停下来交换：选择这个方法。

  ​		若数组中元素全部相等，则会做多次多余交换。复杂度nlogn

  * 不理他，继续移动指针：

    若等于主元，则不理他，可以避免很多无用的交换，复杂度n^2^.

* 小规模数据的处理：

  快速排序的问题：

  ​	用递归，占用额外的系统堆栈的空间，需要多次入栈和出栈操作。因而对于小规模的数据（例如N不到100）可能还不如不如插入排序快。

  解决方案

  当递归的数据规模充分小，则停止递归，直接调用简单排序（例如插入排序）

  *程序中定义一个Cutoff的阈值——课后去实践一下，比较不同的Cutoff对效率的影响*

算法实现：

```c
void QucikSort(ElementType A[], int left, int Right)
{
    if (CutOff <= Right - Left)
    {
        Pivot = Media3(A, Left, Right);
        i = Left; j = Right - 1;
        for (;;)
        {
            while (A[++i] < Pivot){}
            while (A[--j] > Pivot){}
            if (i < j)
            {
                Swap(&A[i], &A[j]);
            }
            else
                break;
        }
        Swap(&A[i], &A[Right - 1]);
        // 对中间值两边继续递归调用快速排序
        QuickSort(A, Left, i - 1);
        QuickSort(A, i + 1, Right);
    }
    else
    {
        Insertion_Sort(A + Left, Right - Left + 1);
    }
}

// 封装函数
void Quick_Sort(ElementType A[], int N)
{
    QuickSort(A, 0, N-1);
}
```

快速排序算法不稳定。

### 标排序

适用范围：待排序元素不是简单的整数，而是一个庞大的结构。比如一本书。在排序中不移动数据本身，只移动指向他们的指针。

算法概述：

* 间接排序

定义一个指针数组作为“表”（table)

![image-20201006230235481](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006230235481.png)

如果仅要求按顺序输出，则输出：`A[ table[0] ], A[ table[1] ], ……, A[ table[N-1] ]`

* 物理排序：移动数据本身

N个数字的排列由若干个独立的环组成

例子：

0-> table[3] -> 3 -> table[1] -> 5 ->table[0] -> 0

![image-20201006230452531](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006230452531.png)

先将一个数据拿出来放在旁边，再将环内其他数据进行排序。

`Temp = f`

如何判断一个环的结束？

`if ( table[i] == i )`

算法复杂度：

* 最好情况：初始即有序

* 最坏情况

   有（N / 2）（向下取整） 个环，每个环包含2个元素

  需要（3N / 2）（向下取整） 次元素移动

### 基排序

仅仅基于比较排序算法的时间复杂度下界是nlogn

基数就是进制的基数，十进制基数就是10.

* 桶排序

例子:

假设我们有N 个学生，他们的成绩是0到100之间的整数（于是有 M = 101 个不同的成绩值）。如何在线性时间内将学生按成绩排序？

可以先做根据分数0--100共101个桶，然后遍历学生成绩，根据成绩将对应学生放进桶内。最后按照顺序遍历桶，则得到了有序输出。

![88  100  count ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001-1601997328517.png)

```c
void Bucker_Sort(ElementType A[], int N)
{
    count []; //初始化
    while (读入i个学生成绩grade)
    	将该生成绩插入count[grade]链表;
    for (i = 0; i < M; i++)
    {
        if (count[i])
        {
            输出这个count[i]链表;
        }
    }
}
```

T(N, M) = O(N, M);

==下面的为看懂==

假设我们有N = 10 个整数，每个整数的值在0到999之间（于是有 M = 1000 个不同的值）。还有可能在线性时间内排序吗？

先按0到9建立桶，先按个位数进行排序，再按十位数排序。然后进行收集，收集就是将每个桶的元素用一个链表串起来，最后按照百位数进行排序。

输入序列: 64, 8, 216, 512, 27, 729, 0, 1, 343, 125

用“次位优先”（Least Significant Digit）  T=O(P(N+B)) 

![Bucket  Pass 1  Pass 2  Pass 3  0  1  o  27  64  512  125  512  125  729  216  343  343  125 216  512  729  729 ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001-1601998107950.png)

多关键字的排序：

基数排序在进行多关键字排序的时候可以把关键字看成是其某位，则主关键字看为是高位，此关键字看成是低位。

一副扑克牌是按2种关键字排序的

![image-20201006233200374](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006233200374.png)

* 用“主位优先” ( Most Significant Digit ) 排序：为花色建4个桶

![image-20201006233227210](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006233227210.png)

在每个桶内分别排序，最后合并结果。

* 用“次位优先” ( Least Significant Digit ) 排序：为面值建13个桶基数排序是稳定的算法。

![image-20201006233309475](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/image-20201006233309475.png)

将结果合并，然后再为花色建4个桶。

### 排序算法的比较

![ ](%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89.assets/clip_image001-1601998415188.png)